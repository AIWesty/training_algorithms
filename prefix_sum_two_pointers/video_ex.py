#Префиксные суммы 
#Допустим есть масиив nums длиной N  элементов и нам необходимо отвечать
# на запросы "Чему равна суммаэлементов на полуинтервале [L, R)"

# для этого нам нужно подсчитать массив prefixsum длиной N + 1(тк на первом шаге будет 0), 
# где prefixsum[k] будет хранить сумму всех чисел из nums с индексами от 0 до k -1 

#Массив можно построить за O(n): prefixsum[i](текущий элемент в массиве сумм) = prefixsum[i-1] + nums[i-1]
#равен предыдущей сумме + предыдущему элементу массива nums 
#например индексы 0  1  2  3  4  5  6
        # nums    6  3  5  6  1  2  3    
    #prefixsum.   0  6  9  14 20 21 23

#Не забывать про N + 1 размер массива


#Ответ на запрос суммы на отрезке
#ответ за O(1) при помощи массива преф сумм = sum[L, R) = prefixsum[R] - prefixsum[L]
#например найдем sum(1, 5): prefixsum[5] - prefixsum[1] = 21 - 6 = 15(3 + 5 + 6 + 1)
# с правой границей невключительно

#задача RSQ(range sum query) через префиксные суммы
def make_prefixsum(nums): 
    prefixsum = [0] * (len(nums) + 1)#создаем массив нулей длиной n(длина масива) + 1 
    for i in range(1, len(nums) + 1): #начиная с единицы в преф сум(тк первый эл - 0 )
        prefixsum[i] = prefixsum[i - 1] + nums[i - 1]#текущий эл = предыдущему + предыдуший элемент из массива входного
    return prefixsum

def rsq(prefixsum, l, r):
    return prefixsum[r] - prefixsum[l]#возвращаем сумму интервала (от правой границы отнимаем левую)
    

#задача номер 1 
#простое решение с пробегом каждого интервала на поиск нулей ([L:R)) O(N * M)
def count_nulls(seq, l, r): 
    cnt = 0 
    for i in (l, r): 
        if i == 0: 
            cnt += 1 
    return cnt

#решение за O(n + m), для каждого префикса считаем колво нулей на нем
#(prefixzeroes), тогда ответ на полуинтервале будет przeroes[R] - przeroes[L]
#      nums 1 0 0 1 1 0 1 0 1
#prefzeroes 0 0 1 2 2 2 3 3 4  смотрим какой элемнт на nums[i - 1], если 0, то сумма +1 , если другое то не меняем

def make_prefix_zeroes(nums): 
    prefix_zeroes = [0]  * (len(nums + 1 )) #заполняем нулями список по длине n + 1
    for i in range(1, len(nums + 1 )):#по длине входного массива
        if nums[i - 1] == 0:#если предыдущий элемент 0 
            prefix_zeroes[i] = prefix_zeroes[i - 1] + 1 #то текущая сумма будет - пред сумма + 1
        else:
            prefix_zeroes[i] = prefix_zeroes[i - 1]#иначе сумма остается пред
    return prefix_zeroes

def counting_zeroes(prefix_zeroes, l, r): 
    return prefix_zeroes[r] - prefix_zeroes[l]#выводим ответ нулей, правая граница полуинтер - левая



#задача номер 2, есть последовательность n
#Необходимо найти количество отрезков с нулевой суммой.
#простое решение за O(n ** 3) c перебором каждого отрезка
def count_zeroes_sum_range(nums): 
    cnt_ranges = 0 #счетчик отрезков с нулевой суммой
    for i in range(len(nums)):#пробегаемся по входящему массиву(левая граница)
        for j in range(i + 1, len(nums) + 1):#от след элемента до длины последовательнсти(правая граница)
                rng_sum = 0 #счетчик суммы
                for k in range(i, j): #бегает от левой до правой границы
                    rng_sum += nums[k] #прибавляет элемент
                if rng_sum == 0: #если на этом интервале сумма 0
                    cnt_ranges += 1# то к ответу + 1
    return cnt_ranges

#O(n ** 2)
def count_zer_sum_ran(nums): 
    cntranges = 0 #счетчик интервалов
    for i in range(len(nums)):#i пускаем по последовательности
        range_sum = 0 #счетчик суммы на отрезке
        for j in range(i, len(nums)): #от i до длины массива(то есть от i(левая граница) двигаем j до конца(правая граница))
            range_sum += nums[j]#считаем сумму на отрезке
            if range_sum == 0: #если сумма отрезка 0 
                cntranges += 1#то в ответ +1
    return cntranges

#O(n)
def count_pref_sum(nums):
    prefix_sum_value = {0: 1} #создаем словарь ключ - сумма, значение - сколько раз ее встречали
    nowsum = 0 #текущая сумма
    for now in nums: #по массиву
        nowsum += now #считаем текущую сумму
        if nowsum not in prefix_sum_value: #если ее нет в словаре 
            prefix_sum_value[nowsum] = 0 #инициализируем 0
        prefix_sum_value[nowsum] += 1#прибавляем 1
        return prefix_sum_value #возвращаем словарь преф сумм\
            
def count_zero_ranges_sum(prefix_sum_value):
    cnt_ranges = 0#счетчик интервалов
    for i in prefix_sum_value: #по словарю сумм
        cntsum = prefix_sum_value[i] #счетчик суммы = значению словаря по текущему i
        cnt_ranges += cntsum * (cntsum - 1) // 2 #подсчет интервалов формулой
    return cnt_ranges
#это решение более математическое из за использования формулы,
# можно прибавлять сумму сразу как встретилась в первой функции


#ДВА УКАЗАТЕЛЯ , ДЛЯ НИХ ВСЕГДА НАДО ПОМНИТЬ, ОТСОРТИРОВАН ЛИ МАССИВ
#два указателя по времени выполнения чаще работают за линейное время O(n),
#например для задачи где у нас при выполнении условия двигается правый укаатель, 
#мы пройдем массив им всего один раз(левым также в худшем случае), поэтому получается n элементов

#если задача где два указателя двигаются на встречу друг другу то также они сделают один проход 
#в задачах расходящихся указателей с центра также 

#задача 3

#Дана отсортированная последовательность чисел длиной N и число К
#Необходимо найти количество пар чисел А, В, таких что В - А > К.
#[1, 3, 5, 6, 7, 8, 10, 12], k = 6

#решение за O(n ** 2) через 2 цикла без указателей
def count_pairs(sorted_nums, k):
    pairs = 0 #счетчик пар
    for first in range(len(sorted_nums)):#первый цикл по длине массива(левая граница)
        for last in range(first, len(sorted_nums)): #второй массив от левой до конца(правая граница, двигаем)
            if sorted_nums[last] - sorted_nums[first] > k: #если правая - левая текущие больше k 
                pairs += 1 #то пара + 1
    return pairs

#решение за O(n)
#Возьмем наименьшее число и найдем для него первое подходящее большее. 
# Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, 
# а указатель первого подходящего большего будем двигать начиная с той позиции,
# где он находится сейчас

def count_pars(sort_nums, k): 
    cnt_pair = 0 #счетчик пар
    last = 0 #второй указатель
    for first in range(len(sort_nums)):#первый указатель(левый)
        while last < len(sort_nums) and sort_nums[last] - sort_nums[first] <= k:#пока правый указатель меньше длины масива
            #и выполняет условие 
            last += 1 #правый указатель двигаем 
        cnt_pair += len(sort_nums) - last #счетчик увеличиваем на разницу длины масива и второго указателя
    return cnt_pair


#задача 4 
#Игрок в футбол обладает одной числовой характеристикой — профессионализмом.
# Команда называется сплоченной, если профессионализм любого игрока не превосходит 
# суммарный профессионализм любых двух других игроков из команды.
#команда может состоять из любого количества игроков.
#Дана отсортированная последовательность чисел длиной N — профессионализм игроков
#Необходимо найти максимальный суммарный профессионализм сплоченной команды.

#O()
def best_sum_team(players):
    best_sum = 0#лучшая сумма
    now_sum = 0 #текущая сумма мастерства
    right = 0 #индекс правого указателя
    for left in range(len(players)):#левый указатель по последовательности
        while right < len(players) and (left == right or players[left] + players[left + 1] >= players[right]):
            #правый указатель двигаем пока он не вышел за длину масива
            #и или левый и правый не сравнялись(1 элемент в массиве)
            # или левый и левый +1 равны правому
            now_sum += players[right]#текущая сумма + правый указатель 
            right += 1#правый двигаем
        best_sum = max(best_sum, now_sum)#лучшая сумма из предыдущей и текущей
        now_sum -= players[left]#текущую уменьшаем на левый указатель, то есть при сдвиге левого 
        #указателя двигаем сумму на 1 
    return best_sum



#задача 5 
# Даны две отсортированные последовательности чисел (длиной N и М соответственно)
# Необходимо слить их в одну отсортированную последовательность.
def merging_list(nums1, nums2):
    merged = [0] * (len(nums1) + len(nums2))#выделяем память под массив
    first1 = first2 = 0 #два указателя для двух массивов на ноль
    for k in range(len(nums1) + len(nums2)): #по индексам массива(двух длин)
        if first1 != len(nums1) and (first2 == len(nums2) or nums1[first1] < nums2[first2]):
        #если первый список не закончился и или второй уже закончился или указатель(элемент) во втором больше текущего первого
            merged[k] = nums1[first1]#то по k индексу будет лежать элемент из первого массива по первому указателю
            first1 += 1#двигаем указатель
        else:
            merged[k] = nums2[first2]#в k будет лежать эл из 2 массива 2 указателя
            first2 += 1#двигаем указатель
        return merged
    
