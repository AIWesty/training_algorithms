#A. Стильная одежда

#решение за O(n + m )  два указателя, тк 2 масисва отсортированы
def greates_pairs_clothes():
    N = int(input())  # вводим n
    shirts = list(map(int, input().split()))  # вводим массив футболок
    
    M = int(input())  # вводим m 
    pants = list(map(int, input().split()))  # вводим массив штанов
    
    i, j = 0, 0  # два указателя, оба на нулевой элемент
    best_pair = (shirts[0], pants[0])  # лучшая пара, изначально первые элементы (закрывает краевые варианты)
    min_diff = abs(shirts[0] - pants[0])  # начальная минимальная разница
    
    while i < N and j < M:  # пока не исчерпали длину
        shirt = shirts[i]  # текущая футболка
        pant = pants[j]  # текущие штаны
        diff = abs(shirt - pant)  # текущая разница между элементами
        
        if diff < min_diff:  # если текущая разница меньше минимальной
            min_diff = diff  # то минимальную обновляем, делаем текущей
            best_pair = (shirt, pant)  # лучшая пара становится текущей

        if diff == 0:  # если разница 0, заканчиваем цикл — лучше пары не будет
            break
        
        if shirt < pant:  # двигаем указатели, если текущая футболка меньше штанов
            i += 1  # то увеличиваем указатель у футболки, чтобы сократить разницу
        else: 
            j += 1  # иначе наоборот
            
    print(best_pair[0], best_pair[1])  # возвращаем пару 

greates_pairs_clothes()

# B. Сумма номеров
#задача на префиксные суммы 
#решение за O(n) time, space O(n)
def count_pairs_nomer():
    n, k = list(map(int, input().split()))#ввод количества и подходящего числа
    car_license_plates = list(map(int, input().split()))#ввод массива номеров
    count = 0#счетчик подотрезков
    current_sum = 0
    prefix_counts = {0: 1}  # сумма 0 уже есть (для подотрезков, начинающихся с нуля)
    #для счетчика количества вхождения преф сумм, ключ - преф сумма, значение - количество нахождения преф суммы
    
    for num in car_license_plates:#по массиву номеров
        current_sum += num#текущая сумма
        
        # Если раньше была сумма current_sum - k, то подотрезок с суммой k найден
        if (current_sum - k) in prefix_counts:#находим что была левая граница, а то есть и подотрезок удовлетворяющий условие 
            count += prefix_counts[current_sum - k]
        
        # Обновляем количество текущей суммы
        prefix_counts[current_sum] = prefix_counts.get(current_sum, 0) + 1            
    print(count)
count_pairs_nomer()

            # 5 17
            # 17 7 10 7 10
            # 17 24 34 41 51

#C. Туризм
#будем решать сделав 2 массива преф сумм, один слева направо, другой справа налево, далее высчитываем сумму исходя из входящего запроса
def calculation_highest_highway(): 
    # Читаем количество точек
    n = int(input())
    y_coords = []#сохраняем кординаты высоты

    # Сохраняем только y-координаты
    for _ in range(n):
        x, y = map(int, input().split())#сохраняем кор высоты в массив
        y_coords.append(y)
    
    up_forward = [0] * n #создание преф сумм слева направо
    for i in range(1, n): #от 1 до длины массива
        if y_coords[i] > y_coords[i - 1]: #если текущее выше предыдущего
            up_forward[i] = up_forward[i - 1] + (y_coords[i] - y_coords[i - 1])#то текущая сумма равна пред + разница между текущим y и пред
        else:
            up_forward[i] = up_forward[i - 1]#иначе текущая сумма равна предыдущей(если число меньше)
            
    up_backward = [0] * n #создание преф сумм справа налево
    for i in range(n - 2, -1, -1):# обратный цикл с отступом на 1 элемент от конца, тк первый 0
        if y_coords[i] > y_coords[i + 1]:#если текущая больше пред
            up_backward[i] = up_backward[i + 1] + (y_coords[i] - y_coords[i + 1])#то текущая сумма равна пред + разница двух элементов
        else:
            up_backward[i] = up_backward[i + 1]#иначе просто пред сумме
    
    m = int(input())#вводим трассы

    for _ in range(m):#цикл по трассам
        start, end = map(int, input().split())# начало и конец трасс(вершин)
        start -= 1  # переводим в 0-индексацию 
        end -= 1

        if start < end:#если конец больше начала то считаем слева направо
            result = up_forward[end] - up_forward[start]#сумму с конца отнимаем с суммой начала с первого массива
        elif start > end:#если старт больше конца то справа налево
            result = up_backward[end] - up_backward[start]#также конец - старт только сдругого массива
        else:
            result = 0

        print(result)
calculation_highest_highway()

# D. Город Че
#тк массив отсортирован то мы можем обойтись только двумя указателями, проверяя больше ли сумма чем видимость 


def counting_number_ways(): 
    n, r = list(map(int, input().split()))#считываем длину и видимость
    distances = list(map(int, input().split()))#массив расстояний
    
    count = 0 #счетчик подходящих интервалов
    right = 0#правый указатель
    for left in range(n): #левый указатель по длине массива
        while right < n and distances[right] - distances[left] <= r: #пока правый указатель не вышел за предел
            # и дистанции между указателями(интервал) меньше чем видимость, считается от правого отнимаем левый
            right += 1# мы двигаем правый указатель
            #как только дойдем до того что сумма на интервале станет больше видимости выйдем из цикла
        count += n - right # в счетчик добавим "элемент" от длины масива до правого указателя
        #тк все элементы правее чем правый указатель тоже подойдут, тк там сумма будет тоже больше чем видимость б
    print(count)#выводим счетчик
    
counting_number_ways()
        
        
# E. Красота превыше всего
#решение за O(n) time, O(k) space, тк словарь с подсчетом размером k элементов
def minimal_trees_way():
    from collections import defaultdict
    
    n, k = list(map(int, input().split())) #вводят длину и кол-во разныъ
    trees = list(map(int, input().split()))#вводят деревья
    
    left = 0 #левый указатель
    count = defaultdict(int)#словарь подсчета 
    unique = 0 #уникальные 
    min_len = float('inf')#минимальная длина
    result = (0,0)#отрезок ответа
    
    for right in range(n): #пускаем правый указатель бегать по длине
        color = trees[right]#текущий цвет, в последовательности выбираем текущее дерево(цвет)
        if count[color] == 0: #если мы не встречали такой вид, то считаем его уникальным
            unique += 1
        count[color] += 1 #прибавляем к счетчику
        
        while unique == k: #когда мы от левого до правого указателя соберем k уникальных элементов(будут все цвета)
            current_length = right - left + 1#текущая длина это правый указатель минус левый + 1 из за индексации с нуля
            if current_length < min_len: #если текущая меньше минимальной
                min_len = current_length#минимальная равна текущей
                result = (left+1, right + 1)#записываем результат, +1 индексация
                
            left_color = trees[left]#мы берем цвет левого указателя 
            count[left_color] -= 1 #и вычитаем одно нахождение, чтобы подвинуть левый указатель
            if count[left_color] == 0: #если этого цвета остается 0  в словаре подсчета
                unique -= 1#то уникальных на 1 меньше
            left += 1#двигаем левый указатель правее на 1
    print(result[0], result[1])
minimal_trees_way() 


#F. Кондиционеры
#решение это будет составить массив минимальной цены для каждой мощности, далее пройтись по 
#требуемым мощностям, и из массива с ценами суммировать минимальную цену которую мы нашли ранее для этой мощности 

#time O(m + n log n), space O(1)
def count_minimal_cost(): 
    n = int(input())#количество классов 
    a = list(map(int, input().split())) #массив мощностей для классов 
    m = int(input())#количество предлагаемых кондиционеров
    
    max_power = 1000 
    min_cost = [float('inf')] * (max_power + 2) #создаем массив минимальных цен мощностей >= p
    
    for i in range(m):
        #тут мы будем обращаться к массиву по индексу(поступаемой мощности), а в нем по этому индексу лежит цена за эту мощность
        b, c = map(int, input().split())#считываем мощность кондея и его цену
        if c < min_cost[b]: #если текущая цена меньше чем цена за эти ваты в массиве цен
            min_cost[b] = c#то найдена новая минимальная цена
    
    #этим циклом заполняем пропуски для массива стоимостей, подбираем минимальную цену для каждого 
    for j in range(max_power, 0, -1):#идем по индекса мощности в обратном порядке
        if min_cost[j] > min_cost[j + 1]:#если текущая цена больше, чем цена кондея, который мощнее
            min_cost[j] = min_cost[j + 1]#то мы берем кондей мощнее за меньшую цену
    
    a.sort()#сортируем мощности которые нужны для классов
    
    total = 0 #итоговая цена
    for power in a: #пробегаемся по массиву с нужными мощностями
        total += min_cost[power]#прибавляем к цене минимальную цену по этой мощности из массива с ценами за мощность
    print(total)
    
count_minimal_cost()



#G. Счет в гипершашках
#идея решения заключается в сортировке массива карточек, для того чтобы проверять пары на соответствию условию
#далее двигать указатели и прибавлять к счетчику кол-во вариантов 
def calculate_uniqe_count(): 
    n, k = map(int, input().split())
    checkers = list(map(int, input().split()))
    
    checkers.sort()#сортированный массив карточек
    
    res = 0
    j = 2
    
    for i in range(n - 2):#проходим по списку 
        while j < n and checkers[j] <= checkers[i] * k: #пока правый указатель не достиг границы и правый указатель меньше или равен левому * на макс разницу элементов
            j += 1#двигаем правый указатель 
        m = j - i - 1 #кол-во элементов между левым и правым указателем
        if m >= 2: 
            res += m * (m - 1) // 2 
    print(res)
            
#подстрока
#решение: sliding window, делаем массив для подсчета кол-ва вхождений, проверяем, если элемент входить больше k раз(допустимого), то мы двигаем левый указатель до тех пор, пока не найдем такую подстроку, где элемент встречается меньше(<=) k раз, как находим проверяем длину и находим ее начало

#time O(n) в худшем случае, тк указатель может пробежать всю строку, space O(n)
def find_length_under_str(): 
    n, k = map(int, input().split())
    stroke = input().strip()#строка длиной n
    
    count = [0] * 26#массив размера латинского алфавита
    max_len = 0 #максимальная длина
    best_left = 0
    left = 0 #левый указатель
    #тут мы считаем сколько раз встречается элемент, записываем в массив
    for right in range(n):#правый указатель по массиву
        char = ord(stroke[right]) - ord('a')
        count[char] += 1
        #как только текущего элемента(это будет первое нахождение насоответствия) будет больше чем можно, то мы двигаем левый указатель до тех пор, пока количество не будет допустимым
        while count[char] > k: #пока кол-во текущего элемента больше чем максимально допустимое количество
            left_char = ord(stroke[left]) - ord('a')#вычисляем какая буква на левом указателе
            count[left_char] -= 1 #вычитаем ее из массива с вхождениями
            left += 1#двигаем левый указатель вправо
        
        if right - left + 1 > max_len: #проверка на максимальную длину, если разница между указателями больше чем текущая макс длина, то 
            max_len = right - left + 1 #новая макс длина будет разницей
            best_left = left#запоминаем начало лучшей подстроки
    print(max_len, best_left + 1) #+1 из за индексации, в ответ идет с какого ЭЛЕМЕНТА
    
find_length_under_str()


#I. Робот
#подходящяя послед операций, где робот делает k + 1 действие, делает это он циклично, поэтому первые k символов должны повторяться

#мы находим подходящую подстроку проверкой если элемент = элементу +k (то есть два элемента одинаковые, то между ними может быть цикличная последовательность элементов которая нам подходит), мы внутренним циклом проверяем и прибавляем длину, если цикл не вышел за длину строки и элемент стоящий на индекса текущего элемента + length = элементу на таком же индексе только +k(то есть по сути проверка на схожесть элементов между началом и концом подстроки), увеличиваем длину для проверки следующего элемента подстроки
def find_quantity_profitable_use():
    import sys
    k = int(sys.stdin.readline())
    stroke = sys.stdin.readline().strip()
    
    res = 0

    for i in range(len(stroke) - k): #идем  по строке до длины - k, тк нам нужно k + 1 элементов и когда мы будем на элементе с индексом len - k, это будет последний элемент чтобы не вылезть за длину массива
        if stroke[i] == stroke[i + k]: #если текущий элемент равен элементу на +k позиции(то есть циклично повторяется) и мы нашли подстроку для проверки
            length = 1
            while (i + k + length < len(stroke)) and (stroke[i + length] == stroke[i + k + length]): #пока(то есть) элемент + память + длина подстроки меньше длины нашей строки и элемент стоящий на + length равен элементу на +k, простыми словами что следующий элемент от прошлого равен элементу на +k, что будет подтверждать цикличность
                length += 1 #увеличиваем длину, для проверки следующего элемента в подстроке
            res += length#в результат добавляем 
            i += length
        else: 
            i += 1
    print(res)
find_quantity_profitable_use()


#j. Треугольники 
#подход решения хранение расстояний

#составляем массив квадратов расстояний для каждой точки(точку считаем вершиной треугольника) далее сортируем массив, пробегаем по нему и ищем для каждого расстояния есть ли равное ему, а из количества равных состояний по формуле выводим общее количество треугольников
def find_quantity_triangles(): 
    n = int(input())
    pointers = [tuple(map(int, input().split())) for _ in range(n)]
    
    count = 0 
    
    for i in range(n): #проходим по циклу 
        x0, y0 = pointers[i]#текущая точка, координаты
        distances = []
        for j in range(n): 
            if i == j: #встретили такой же элемент, пропустили тк нам нужна площадь >0
                continue
            dx = pointers[j][0] - x0#расстояние между точкой и вершиной(точкой из цикла выше)
            dy = pointers[j][1] - y0
            dist_sq = dx * dx + dy * dy #квадраты расстояний
            distances.append(dist_sq)#добавили все квадраты в массив растояний
            
        distances.sort() 
        
        left = 0
        
        while left < len(distances):#идем циклом по массиву расстояний 
            right = left#левый и правый указатель равняем, начиная с 0
            while right < len(distances) and distances[right] == distances[left]:#пока правый указатель не вышел за границу и точки на двух указателях равный
                #увеличиваем правую границу, пока не будет найдено новое расстояние
                right += 1#если мы нашли 2 точки на одинаковом расстоянии(длина тоже одинакова)
            cnt = right - left#считаем сколько точек с одинаковым расстоянием было 
            if cnt >= 2: #если более 2 
                count += cnt * (cnt - 1) // 2
            left = right #пропускаем точки до правой границы 
    print(count)
                
find_quantity_triangles()
