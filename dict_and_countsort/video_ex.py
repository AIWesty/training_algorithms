#сортировка подсчетом 

#возьмем на примере словаря и оценок в школе
#нам нужно отсортировать массив оценок, например - [5, 4, 3, 4, 5, 4, 2, 5, 3, 2, 5, 4, 1, 4]
#если размер k(в данном случае 5, тк "типов" оценок всего 5, от 1 до 5), то мы можем воспользоваться сортировкой подсчетом
#создаем словарь, где ключи это оценки от 1 до 5, а ключи количество вхождений, дальше просто выводим ключи в количестве значений 

#такая сортировка будет работать за O(n + k), по памяти O(k), в случаях где k маленькое это удобно 

#реализация алгоритма сортировки подсчетом
def count_sort(seq): 
    minimal = min(seq)#считаем минимальный и максимальный элемент
    maximum = max(seq)
    k = (maximum - minimal + 1)#считаем размер k(для заполнения)
    count = [0] * k #создаем список k элементов заполненный нулями
    for now in seq: 
        count[now - minimal] += 1#делаем подсчет элементов 
    now_pos = 0#текущая позиция 
    for val in range(0, k): #по всему массиву(посчитанному)
        for i in range(count[val]): #для каждого элемента, повторяем столько раз сколько он встречается
            seq[now_pos] = val + minimal#записываем значение в исходный массив
            now_pos += 1#текущая позиция + 1


#задача 1 сортировка подсчетом, решение из видео
def is_digit_permutation(x: int, y: int) -> bool: 
    
    
    def count_digits(num: int) -> list: #функция для подсчета вхождений цифр
        digit_count = [0] * 10 #создаем список с 10 элементами(нулями)
        while num > 0: #пока переданное число больше нуля
            last_dig = num % 10 #вычисляем последний элемент числа
            digit_count[last_dig] += 1 #по индексу последнего элемента мы прибавляем 1(нам встретился этот элемент)
            num //= 10 #от числа отнимаем последнее чилос
        return digit_count #возвращаем последовательность
    
    digit_x = count_digits(x)#преобразуем число в список с посчитанными вхождениями
    digit_y = count_digits(y)
    
    for digit in range(10): #цикл 10 раз, тк два массива одинаковой длины = 10 элементов
        if digit_x[digit] != digit_y[digit]: #если по какому то из индексов массивы не равны, то из одного нельзя сделать друшое
            return False
    return True


#задача номер 2 словари, решение с видоса(проверить сколько ладей бьют дру друга, данные поступают в виде пар координат)
def count_beating_rooks(rookcoords):
    
    
    def addrock(row_or_col, key): #функция добавления в словарь бьющих ладей
        if key not in row_or_col: #если по такой координате нет записи в словаре создаем новую
            row_or_col[key] = 0 #присваем ей 0 
        row_or_col[key] += 1 #увеличиваем на 1 
        
        
    def count_pairs(row_or_col): #функция подсчета пар
        pairs = 0 #начальное колво пар
        for key in row_or_col:#в словаре с парами по ключам
            pairs += row_or_col[key] - 1 #в парах прибавляем
        return pairs
            
    
    
    rooks_in_row = {} #создаем пустые словари для горизонтали и для вертикали
    rooks_in_col = {} 
    for row, col in rookcoords: #ключ значение по координатам которые принимаем
        addrock(rooks_in_row, row)#добавляем бьющие ладьи в словари, передаем словарь и координату
        addrock(rooks_in_col, col) #горизонтали и вертикали
    return count_pairs(rooks_in_row) + count_pairs(rooks_in_col) #считаем пары в обоих словарях и скалыдваем

#задача номер 3 с видео

def print_char(s):
    sym_count = {}#пустой словарь для подсчета вхождений
    max_symbol_count = 0#самый часто встречающийся символ
    for sym in s: #по строке
        if sym not in sym_count: #если нет в словаре
            sym_count[sym] = 0 
        sym_count[sym] += 1
        max_symbol_count = max(max_symbol_count, sym_count[sym])#смотрим какой символ чаще встречается(по сути можно после цикла)
    sorted_sym_count = sorted(sym_count.keys())#делаем отсортированный словарь по ключам для вывода
    for row in range(max_symbol_count, 0, -1): #от кол-ва самого встречающегося символа до нуля не вкл
        for sym in sorted_sym_count:#пробегаемся по  словарю
            if sym_count[sym] >= row: #если он встречается больше или столько же текущего то выводим решетку
                print('#', end='')
            else: 
                print(' ', end='')#если нет то пробел
        print()
    print(''.join(sorted_sym_count))
    

#тема задел под оптимизацию, нужно помнить о времени которое вы тратите на алгоритм, память и деньги(оборудование, сотрудников)
#задача с литкода
#суть задачи - сгруппировать по массивам строки(слова) которые состоят из олинаковых букв(eat, tea, ate)

#реализация, решение здорового человека
def groupwords(words): 
    group_words = {}#создаем словарь
    for word in words: #проходим по введенному массиву слов
        sortedword = ''.join(sorted(word))# сортируем текущее слово(по буквам) !можно сделать сортировку
        if sortedword not in group_words: #если его нет в словаре 
            group_words[sortedword] = [] #то по его ключу создаем пустой список 
        group_words[sortedword].append(word) #добавляем это слово(не сортированное, а то которое пришло)
    ans = [] #создаем список для ответа
    for sortword in group_words:#пробегаем по нашему словарю с ключами - сорт, а значениями словами пришедшими
        ans.append(group_words[sortword])#в ответ по ключу добавляем список слов(пришедшие)
    return ans
    


