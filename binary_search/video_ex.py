#бинарный поиск
#это поиск какого то элемент в упорядоченной последовательности
#теминология - 

#левый бинарный поиск, это когда в последовательности идут элементы "плохие", 
#то есть не подходящие нам, а потом идут элементы большие или равные искомому, которые мы считаем
#"хорошими", наша задача будет найти первое "хорошее слово"

#правый бинарный поиск, наоборот, когда в последовательности идут "хорошие" элементы, 
#потом начинаются "плохие", и наша задача найти последний "хороший" элемент

#примеры левого и правого бин поиска
#обычно в книгах обьясняют что бин поиск это полуинтервал [l, r), 
#однако в данной версии обьяснения мы будет использовать отрезок [l, r]



# Приоритетный стиль (включительный интервал)

# Лучше всегда писать бинарный поиск с включительными границами [left, right].
# Это классический подход, который:

# Читается интуитивнее (явно включает оба конца),
# Легче запомнить,
# Используется в большинстве учебников и алгоритмических статей.

def lbinsearch(l, r, check, checkparams): #здесь l и r минимальные и максимальные значения функции(можно сказать начало и конец последовательности)
    while l < r: #пока l меньше r(на отрезке l левая граница)
        m = (l + r) // 2 #m - это текущая середина отрезка между l и r
        if check(m, checkparams): #функция проверки m(текущей середины для сдвига) и доп параметров
            #то есть мы функцией проверяем является ли m подходящем или нет(куда двигаться)
            r = m #двигаем правую границу на m
        else: 
            l = m + 1 #иначе левая граница на m + 1 
        return l #возвращаем l

#условный чек мог бы выглядеть так(для левого)
def check(m, main_search): #принимаем текущую середину и искомый элемент
    if m >= main_search: #если текущий m больше или равен искомому то возвращаем True(для сдвига правой границы)
        return True
    else: 
        return False#иначе false для сдвига левой
    
    
def rbinsearch(l, r, check, checkparams): #принимаем параметры
    while l < r: #пока l меньше r(пока указатели не станут равны)
        m = (l + r + 1) // 2#ставим середину(текущую), округляем до большего элемента(+1)
        if check(m, checkparams): #если проверка(например m <= main_search return true), то есть текущая середина 
            #меньше чем искомое число, то на место середины двигаем левый указатель
            l = m 
        else: 
            r = m - 1#иначе правый на m-1 чтобы не произошло ошибка при 2 элементах
            #когда указатели неправильно показывают 
        return l


#задача 1 
#В управляющий совет школы входят родители, учителя и учащиеся школы,
# причём родителей должно быть не менее одной трети от общего числа членов совета.
# В настоящий момент в совет входит N человек, из них К родителей

#Определите, сколько родителей нужно дополнительно ввести в совет, 
# чтобы их число стало составлять не менее трети от числа членов совета.

#тут задача решается при помощи "левого" бин поиска, то есть когда у идут "плохие" эл, потом "хорошие"
#и нам надо выбрать первое "хорошее" значение, которое подходит по правилам

def checkendownment(m, params): #принимает текущую середину и параметры(количество участников и родителей)
    n, k = params#берем из параметров n, k 
    return (k + m) * 3 >= n + m #булево значение от проверки колво родителей + новодобавленные * 3 >= длина + новодобавленные


def lbinsearch_for_first(l, r, check, *args): #принимаем параметры
    while l < r: #пока левый указатель не дошел до правого
        m = (l + r) // 2 #вычисляем текущее колво элементов которое надо добавить 
        if check(m, *args): #проверяем функцией
            r = m #если теперь родителей больше 1/3 то правую границу ставим на m
        else: 
            l = m + 1#иначе левую на m + 1
        return l

lbinsearch_for_first(0, 10000, checkendownment, 123)

#задача 2 
#Юра решил подготовиться к собеседованию в Яндекс. Он выбрал на сайте leetcode N задач
# В первый день Юра решил К задач, а в каждый следующий день Юра решал на одну задачу
# больше, чем в предыдущий день

#Определите, сколько дней уйдет у Юры на подготовку к собеседованию.

def check_minimal_day(l, r, check, checkparams): 
    #l = K, r = N (N // 2 + k)
    while l < r: 
        m = (l + r ) // 2
        #на D-й день будет решено K + (D - 1), тк в перый день было решено k, а не k + 1
        #по сути плюс начинается со второго дня поэтому на любом дне будет - 1 кроме первого
        total = m * (2 * l + m - 1) // 2#формула арифм прогрессии 
        if total >= r:#если значение по формуле больше или равно правой границу то мы двигаем
        #правый указатель на m, чтобы найти меньшее число при котором мы будем выполнять условие 
            r = m 
        else: 
            l = m + 1#иначе двигаем левый указатель
        return l

#задача 3 
#Михаил читает лекции по алгоритмам. За кадром стоит доска размером W * Н сантиметров.
# Михаилу нужно разместить на доске
#N квадратных стикеров со шпаргалками, при этом длина 
# стороны стикера в сантиметрах должна быть целым числом

#Определите максимальную длину стороны стикера, чтобы все стикеры поместились на доске.

def find_max_length_sticker(l, r, check, checkparams):
    while l < r: #где l=1 а r = w * h 
        mid = (l + r + 1) // 2 # идем по логике что сначала все "хорошо", стикеры влезают на доску
        #потом будет последний подходящий элемент, и дальше все будет "плохо", стикеры вылезут за доску
        if check(mid, checkparams): #проверяем текущую выбранную середину
            #если текущая площадь подходит
            l = mid#двигаем левый указатель
        else: 
            r = mid - 1#иначе двигаем правый указатель - 1
        return r
        
def check1(mid, params): 
    n, w, h = params#определяем количество стикеров, ширину и всоту
    return (w // mid) * (h // mid) >= n #если ширина и высота деленые на текущую площадь больше или равны количеству стикеров

#задача 4 
#Задана отсортированная по неубыванию последовательность из N чисел и число Х
#Необходимо определить индекс первого числа в последовательности, 
# которое больше либо равно Х. Если такого числа нет, то вернуть число N.

def find_index(l, r, check, params):
    while l < r: #пока не сойдутся указатели
        mid = (l + r) // 2 #середина
        if check(mid, params):#проверяем условие задачи
            r = mid#если текущая середина больше искомого значения, то двигаем правый
        else: 
            l = mid + 1#иначе левый
    return l 

def check(mid, params): 
    seq, x = params#последовательность и иск число 
    return seq[mid] >= x #здесь mid - index, проверяем текущий элемент больше или равен иск


def find_first_ge(seq, x):
    ans = find_index(0, len(seq) - 1, check, (seq, x))#ищем индекс 
    if seq[ans] < x: #если элемент по индексу меньше искомого(число в посл отсутсвтует)
        return len(seq)#то вернем длину последовательности(n)
    return ans


#задача 5 
#Задана отсортированная по неубыванию последовательность из N чисел и число Х
#Необходимо определить сколько раз число Х входит в последовательность.

#решение будет использовать два бинпоиска, ищем элемент который равен x и вторым ищем
#жлемент который больше x, разница их индексов - количество x элементов 

def find_x_and_better_x(l, r, check, params): #здесь l - начало последовтельности, r конец последовательности
    while l < r: #обычный бин поиск пока два указателя не покажу на 1 элемент
        mid = (l + r) // 2 #текущая середина
        if check(mid, params):#если текущее больше искомого двигаем
            r = mid #правый указатель на середину
        else: 
            l = mid + 1#иначе левый на середину + 1
    return l 
            

def check_x(index, params): #функция для проверки текущей середины на равенство x
    seq, x = params #передаем последовательность и x
    return seq[index] >= x #сравниваем элемент послед

def check_better_x(index, params): #функция для проверки числа большего x
    seq, x = params
    return seq[index] > x

def find_first(seq, x, check): #функция поиска первого подход элемента при помощи функцииспроверки
    ans = find_x_and_better_x(0, len(seq) - 1, check, (seq, x))#найденный элемент бин поиском
    if not check(ans, (seq, x)):#если этот не подходит(краевой случай, в конце последовательности)
        return len(seq)#возвращаем длину строки
    return ans#возвращаем найденный элемент 

def count_x(seq, x): #функция подсчета кол-ва встречающихся x 
    index_x = find_first(seq, x, check_x)#ищем число = x при помощи функции бин поиска и проверки
    index_better_x = find_first(seq, x, check_better_x)#ищем число (индекс) > x 
    return index_better_x - index_x#ответ - разность первого индекса = x и индекса > x


#задача 6 
#Задана процентная ставка по кредиту (Х% годовых), 
# срок кредитования (N месяцев) и сумма кредита (М рублей)
# Необходимо рассчитать размер аннуитетного ежемесячного платежа. это платеж каждый месяц одинаковой суммы


#решение для процентной стаки
def check_month_perc(midperc, yperc):#средний процент, x процент из условия
    midsum = 1 + midperc // 100#считаем средний процент бин поиска
    ysym = 1 + yperc // 100#считаем x процент(год в нашем случае)
    return midsum ** 12 > ysym#если сумма текущая больше чем процент 


def fbinsearch(l, r, eps, check, params): 
    while l + eps < r: #для вещественных чисел будем использовать доп значение, чтобы условие сработало
        mid = (l + r) / 2#середина месяцев(процент) с вещественным делением 
        if check(mid, params): #если найденная сумма больше чем исходная(x)
            r = mid#то двигаем правый указатель на середину
        else: 
            l = mid + 1#иначе левый
        return l
        
        

x = 12 #годовой процент
eps = 0.0001 #число для бин поиска вещественного
mperc = fbinsearch(0, x, eps, check_month_perc, x)#проценты в месяц

#решение для платежа 
def checkcredit(mpay, params):#месячные проценты, параметры
    periods, creditsum, mperc = params #n, m, mperc(посчитанный выше)
    for i in range(periods): #для каждого месяца 
        percpay = creditsum * (mperc / 100)#сколько платим в месяц с процентами
        creditsum -= mpay - percpay#сумма кредита уменьшается на проценты плюс сама сумма
    return creditsum <= 0 #проверяем остался ли человек должен банку



def fbinsearch1(l, r, eps, check, params): 
    while l + eps < r:
        mid = (l + r) / 2
        if check(mid, params): 
            r = mid
        else: 
            l = mid + 1
        return l 
    
    
    
eps = 0.01#для вещественных чисел
m = 10000000#сумма кредита
n = 300#кол-во месяцев\